---
description: Animation implementation patterns, choreography, and common UI animation patterns. Use when implementing specific animation patterns like modals, lists, loading states, or scroll-triggered animations. Includes common mistakes to avoid.
alwaysApply: false
---

# Animation Patterns

Implementation patterns and choreography for common UI animations. Use these patterns to create consistent, performant animations across your application.

## Technical Implementation

### 1. Button Feedback

**MUST**: Add subtle scale down effect when buttons are pressed:
```css
button:active {
  transform: scale(0.97);
}
```

This makes the interface feel instantly more responsive and gives immediate feedback.

### 2. Initial Scale Values

**NEVER**: Animate from `scale(0)`. This makes animations feel off and unnatural.

**MUST**: Use higher initial scale values (`0.9+`) for more gentle, natural, and elegant movement:
```css
.element {
  transform: scale(0.93); /* initial state */
}
```

**Rationale**: Elements that animate from `scale(0)` look like they come out of nowhere. A higher initial value resembles the real world more (like a deflated balloon still has a visible shape).

### 3. Tooltip Behavior

**MUST**: Implement smart tooltip delays:
- First tooltip in a group: Delay before appearing (prevents accidental activation)
- Subsequent tooltips: No delay and no animation (feels faster)

**Implementation example:**
```css
.tooltip {
  transition:
    transform 0.125s ease-out,
    opacity 0.125s ease-out;
  transform-origin: var(--transform-origin);
 
  &[data-starting-style],
  &[data-ending-style] {
    opacity: 0;
    transform: scale(0.97);
  }
 
  /* Disable subsequent animations */
  &[data-instant] {
    transition-duration: 0ms;
  }
}
```

**Note**: Radix UI and Base UI support this pattern through `data-instant` attribute.

### 4. Easing Functions

**MUST**: Use `ease-out` for elements entering or exiting the screen. It accelerates at the beginning, giving users a feeling of responsiveness.

**NEVER**: Use `ease-in` for UI animations. It starts slow and speeds up at the end, which is the opposite of what we want.

**SHOULD**: Use custom easing curves instead of built-in CSS easings. Built-in curves are usually not strong enough.

**Recommended resources**: [easings.co](https://easings.co) for custom easing variations.

**Example comparison:**
- `ease-in`: Starts slow, feels sluggish
- `ease-out`: Starts fast, feels responsive (preferred)
- Custom `ease-out`: More energetic and impactful

### 5. Origin-Aware Animations

**MUST**: Make popovers, dropdowns, and similar components origin-aware. They should scale in from their trigger point.

**MUST**: Set correct `transform-origin`. The default value is `center`, which is wrong in most cases.

**Implementation:**
```css
/* Radix UI */
.radix {
  transform-origin: var(--radix-dropdown-menu-content-transform-origin);
}

/* Base UI */
.baseui {
  transform-origin: var(--transform-origin);
}
```

**Rationale**: Even if the difference seems subtle, unseen details compound. Origin-aware animations create spatial consistency and make interactions feel more connected.

### 6. Animation Speed Guidelines

**MUST**: Keep animations fast:
- **UI animations**: Under `300ms` (general rule)
- **Dropdowns**: `180ms` for optimal responsiveness
- **Tooltips**: `125ms` for enter/exit
- **Button feedback**: Instant (no transition needed for scale)

**SHOULD**: Test perceived performance. A faster animation can make the app feel faster even if actual load time is the same.

### 7. Blur as a Fallback

**SHOULD**: Use `filter: blur()` when nothing else works. If you've tried different easings and durations and something still feels off, add a bit of blur to mask imperfections.

**Example:**
```css
.transitioning-element {
  filter: blur(2px);
  transition: filter 0.2s ease-out;
}
```

**Rationale**: Blur bridges the visual gap between old and new states. Without it, you see two distinct objects, which feels less natural. It tricks the eye into seeing a smooth transition by blending states together.

## Animation Choreography

### 8. Staggered Animations

**SHOULD**: Stagger animations when multiple elements animate together. This creates visual hierarchy and prevents overwhelming the user.

**Implementation with Framer Motion:**
```tsx
<motion.div
  variants={{
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1, // 100ms delay between children
        delayChildren: 0.2,    // Initial delay
      }
    }
  }}
  initial="hidden"
  animate="show"
>
  {items.map((item) => (
    <motion.div key={item.id} variants={itemVariants}>
      {item.content}
    </motion.div>
  ))}
</motion.div>
```

**Guidelines:**
- **Small lists** (2-5 items): `50-100ms` stagger
- **Medium lists** (5-10 items): `30-50ms` stagger
- **Large lists** (10+ items): `20-30ms` stagger or consider virtualization

**NEVER**: Stagger animations for frequently-used interactions. They should be instant.

### 9. Spring Physics

**SHOULD**: Use spring animations for more natural, physics-based motion. Springs feel more organic than easing curves.

**Implementation with Framer Motion:**
```tsx
<motion.div
  initial={{ scale: 0.9, opacity: 0 }}
  animate={{ scale: 1, opacity: 1 }}
  transition={{
    type: "spring",
    stiffness: 300,    // Higher = faster, snappier
    damping: 30,      // Higher = less bouncy
    mass: 0.5,        // Higher = slower to start/stop
  }}
/>
```

**Recommended spring presets:**
- **Gentle**: `{ stiffness: 120, damping: 14 }` - Subtle, smooth
- **Default**: `{ stiffness: 300, damping: 30 }` - Balanced
- **Wobbly**: `{ stiffness: 180, damping: 12 }` - Playful, bouncy
- **Stiff**: `{ stiffness: 400, damping: 40 }` - Quick, minimal bounce

**When to use springs:**
- ✅ Modal/dialog entrances
- ✅ Card interactions
- ✅ Button feedback (subtle)
- ✅ Drag interactions
- ❌ NOT for frequently-used interactions
- ❌ NOT for keyboard navigation

### 10. Animation States & Variants

**MUST**: Define clear animation states using variants pattern for consistency and maintainability.

**Implementation:**
```tsx
const containerVariants = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: { staggerChildren: 0.1 }
  },
  exit: {
    opacity: 0,
    transition: { staggerChildren: 0.05, staggerDirection: -1 }
  }
};

const itemVariants = {
  hidden: { opacity: 0, y: 20 },
  show: { opacity: 1, y: 0 },
  exit: { opacity: 0, y: -20 }
};
```

**Benefits:**
- Consistent animations across components
- Easier to maintain and update
- Better performance (variants are optimized)
- Clear state management

### 11. List Item Animations

**MUST**: Animate list items when adding/removing to maintain spatial awareness.

**Implementation with AnimatePresence:**
```tsx
<AnimatePresence mode="popLayout">
  {items.map((item) => (
    <motion.li
      key={item.id}
      layout
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.8 }}
      transition={{ duration: 0.2 }}
    >
      {item.content}
    </motion.li>
  ))}
</AnimatePresence>
```

**Key points:**
- Use `layout` prop for automatic position animations
- Use `mode="popLayout"` to prevent layout shift
- Keep exit animations fast (`150-200ms`)
- **NEVER** animate list items in frequently-used lists

### 12. Modal & Dialog Patterns

**MUST**: Animate both backdrop and content with proper timing relationships.

**Implementation:**
```tsx
// Backdrop
<motion.div
  initial={{ opacity: 0 }}
  animate={{ opacity: 1 }}
  exit={{ opacity: 0 }}
  transition={{ duration: 0.2 }}
/>

// Content
<motion.div
  initial={{ opacity: 0, scale: 0.95, y: 20 }}
  animate={{ opacity: 1, scale: 1, y: 0 }}
  exit={{ opacity: 0, scale: 0.95, y: 20 }}
  transition={{
    type: "spring",
    stiffness: 300,
    damping: 30,
  }}
/>
```

**Timing:**
- Backdrop: `200ms` fade
- Content: `200-300ms` spring animation
- Exit: Slightly faster than enter (`150-200ms`)

### 13. Page & Route Transitions

**SHOULD**: Use subtle page transitions to maintain spatial context during navigation.

**Implementation:**
```tsx
// In layout or page component
<motion.div
  initial={{ opacity: 0, y: 10 }}
  animate={{ opacity: 1, y: 0 }}
  exit={{ opacity: 0, y: -10 }}
  transition={{ duration: 0.2, ease: "easeOut" }}
>
  {children}
</motion.div>
```

**Guidelines:**
- Keep transitions fast (`150-250ms`)
- Use subtle movement (`10-20px` max)
- **NEVER** animate route changes for frequently-visited pages
- Consider disabling for instant navigation (back button, deep links)

### 14. Loading States

**MUST**: Animate loading states to improve perceived performance.

**Skeleton screens:**
```css
@keyframes shimmer {
  0% { background-position: -1000px 0; }
  100% { background-position: 1000px 0; }
}

.skeleton {
  background: linear-gradient(
    90deg,
    var(--muted) 0%,
    var(--muted-foreground) 50%,
    var(--muted) 100%
  );
  background-size: 1000px 100%;
  animation: shimmer 2s infinite;
}
```

**Spinner guidelines:**
- Faster spinning = perceived faster loading
- Use `transform: rotate()` for smooth animation
- Keep spinner size appropriate (not too large)

**Progress indicators:**
- Animate progress bar smoothly
- Use `ease-out` for progress animations
- Show percentage or estimated time when possible

### 15. Error & Success States

**SHOULD**: Use subtle animations for error and success feedback.

**Error patterns:**
```tsx
// Shake animation for errors
<motion.div
  animate={{
    x: [0, -10, 10, -10, 10, 0],
  }}
  transition={{
    duration: 0.5,
    ease: "easeInOut",
  }}
>
  {errorMessage}
</motion.div>
```

**Success patterns:**
```tsx
// Subtle scale + checkmark animation
<motion.div
  initial={{ scale: 0 }}
  animate={{ scale: 1 }}
  transition={{
    type: "spring",
    stiffness: 500,
    damping: 30,
  }}
>
  <CheckIcon />
</motion.div>
```

**Guidelines:**
- Keep error animations brief (`300-500ms`)
- Success animations can be slightly longer for delight
- **NEVER** use aggressive animations that might startle users

### 16. Scroll-Triggered Animations

**SHOULD**: Use Intersection Observer for scroll-triggered animations.

**Implementation:**
```tsx
const ref = useRef(null);
const isInView = useInView(ref, { once: true, margin: "-100px" });

<motion.div
  ref={ref}
  initial={{ opacity: 0, y: 50 }}
  animate={isInView ? { opacity: 1, y: 0 } : { opacity: 0, y: 50 }}
  transition={{ duration: 0.6, ease: "easeOut" }}
>
  {content}
</motion.div>
```

**Guidelines:**
- Use `once: true` to prevent re-animation on scroll up
- Set appropriate `margin` to trigger before viewport
- Keep animations subtle (`20-50px` movement)
- **NEVER** animate on every scroll event (performance killer)

### 17. Gesture-Driven Animations

**SHOULD**: Support drag, swipe, and pinch gestures with appropriate animations.

**Drag example:**
```tsx
<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 0 }}
  dragElastic={0.2}
  onDragEnd={(event, info) => {
    if (info.offset.x > 100) {
      // Swipe right action
    }
  }}
/>
```

**Guidelines:**
- Use `dragElastic` for natural resistance
- Provide visual feedback during drag
- Snap back smoothly if threshold not met
- Use spring animations for snap-back

### 18. Focus Management Animations

**SHOULD**: Animate focus changes to help users track navigation.

**Implementation:**
```css
/* Smooth scroll to focused element */
:focus-visible {
  scroll-margin-top: 2rem;
  transition: scroll-margin 0.2s ease-out;
}
```

**Guidelines:**
- Use `scroll-margin-top` for proper spacing
- Keep focus ring visible and animated
- Animate focus changes in modals/dialogs
- **NEVER** animate focus for keyboard navigation (should be instant)

### 19. Animation Composition

**MUST**: Combine multiple animation properties thoughtfully.

**Good composition:**
```tsx
<motion.div
  initial={{ opacity: 0, scale: 0.9, y: 20 }}
  animate={{ opacity: 1, scale: 1, y: 0 }}
  transition={{
    opacity: { duration: 0.2 },
    scale: { duration: 0.3, type: "spring" },
    y: { duration: 0.2 },
  }}
/>
```

**Guidelines:**
- Don't animate too many properties at once
- Use different durations for different properties if needed
- Keep total animation time under `300ms`
- Test on lower-end devices

## Common Animation Mistakes & Anti-Patterns

### 20. What NOT to Do

**NEVER** do these:

1. **Animating everything**
   ```tsx
   // ❌ BAD: Animating every list item in a frequently-used list
   {items.map(item => (
     <motion.div animate={{ opacity: 1 }}>{item}</motion.div>
   ))}
   
   // ✅ GOOD: Only animate when adding/removing items
   <AnimatePresence>
     {items.map(item => (
       <motion.li key={item.id} layout>{item}</motion.li>
     ))}
   </AnimatePresence>
   ```

2. **Using slow animations for feedback**
   ```tsx
   // ❌ BAD: 500ms button press animation
   <motion.button whileTap={{ scale: 0.9 }} transition={{ duration: 0.5 }} />
   
   // ✅ GOOD: Instant or very fast feedback
   <motion.button whileTap={{ scale: 0.97 }} transition={{ duration: 0.1 }} />
   ```

3. **Animating keyboard navigation**
   ```tsx
   // ❌ BAD: Animated focus changes
   <motion.div animate={isFocused ? { scale: 1.1 } : { scale: 1 }} />
   
   // ✅ GOOD: Instant focus changes
   <div className={isFocused ? "ring-2" : ""} />
   ```

4. **Overusing spring animations**
   ```tsx
   // ❌ BAD: Bouncy spring for every interaction
   <motion.div transition={{ type: "spring", stiffness: 100, damping: 10 }} />
   
   // ✅ GOOD: Reserve springs for specific use cases
   <motion.div transition={{ duration: 0.2, ease: "easeOut" }} />
   ```

5. **Ignoring reduced motion**
   ```tsx
   // ❌ BAD: No reduced motion support
   <motion.div animate={{ rotate: 360 }} transition={{ repeat: Infinity }} />
   
   // ✅ GOOD: Respect user preferences
   const shouldReduceMotion = useReducedMotion();
   <motion.div 
     animate={shouldReduceMotion ? {} : { rotate: 360 }}
     transition={{ repeat: shouldReduceMotion ? 0 : Infinity }}
   />
   ```

6. **Animating layout properties**
   ```tsx
   // ❌ BAD: Animating width/height
   <motion.div animate={{ width: isOpen ? 200 : 100 }} />
   
   // ✅ GOOD: Use transform scale or layout prop
   <motion.div layout animate={{ scaleX: isOpen ? 1 : 0.5 }} />
   ```

7. **Blocking user interactions during animation**
   ```tsx
   // ❌ BAD: Disabling interaction during animation
   <motion.div animate={...} style={{ pointerEvents: "none" }} />
   
   // ✅ GOOD: Allow interruption
   <motion.div animate={...} />
   ```

8. **Using too many simultaneous animations**
   ```tsx
   // ❌ BAD: Animating 10+ properties at once
   <motion.div animate={{
     x: 100, y: 50, scale: 1.2, rotate: 45,
     opacity: 0.8, blur: 5, brightness: 1.5
   }} />
   
   // ✅ GOOD: Focus on 2-3 key properties
   <motion.div animate={{ opacity: 1, y: 0 }} />
   ```

9. **Inconsistent animation patterns**
   ```tsx
   // ❌ BAD: Different durations/easings for similar elements
   <Modal1 transition={{ duration: 0.5 }} />
   <Modal2 transition={{ duration: 0.2 }} />
   
   // ✅ GOOD: Consistent patterns using variants
   const modalVariants = { ... };
   <Modal1 variants={modalVariants} />
   <Modal2 variants={modalVariants} />
   ```

10. **Animating on every render**
    ```tsx
    // ❌ BAD: Animation triggers on every state change
    <motion.div animate={{ scale: data.length > 0 ? 1 : 0.9 }} />
    
    // ✅ GOOD: Only animate on meaningful changes
    <motion.div 
      animate={hasData ? "show" : "hide"}
      variants={{ show: { scale: 1 }, hide: { scale: 0.9 } }}
    />
    ```

---

## See Also

- **[Animation Principles](mdc:.cursor/rules/animation-principles.mdc)**: Core principles and when to animate
- **[Framer Motion Guide](mdc:.cursor/rules/animation-framer-motion.mdc)**: Framer Motion best practices and performance
- **[Web Interface Guidelines](mdc:.cursor/rules/web-interface-guidelines.mdc)**: General UI/UX guidelines
- **[Performance Optimization](mdc:.cursor/rules/performance-optimization.mdc)**: Performance best practices
